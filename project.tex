\documentclass{Assignment}
\usepackage{indentfirst}
\usepackage{algorithm2e}
\usepackage{booktabs}   % For \toprule, \midrule, \bottomrule
\usepackage{adjustbox}  % For the adjustbox environment
\usepackage{graphicx}   % Recommended for figures and tables

\usepackage{tikz}
\usepackage{pdfpages}
\usepackage{booktabs}       % For professional-looking tables (\toprule, \midrule, \bottomrule)
\usepackage{adjustbox}      % For table adjustment if it's too wide
\usepackage{textcomp}       % For \textsuperscript
\usetikzlibrary{graphs}
\title{Graph Theory}
\begin{document}

\section*{Task 1}
\subsection*{Introduction}
Main idea of this project is to understand graphs  as a mathematical set and also in a computer science perspective. 
Generally graphs are thought of as usually thought of as functions that are made of axis i.e x and y, and well the z-th axis.
But mathematicians usually study graphs made up of set of vertices(points) with edges(curves) connecting these vertices.
And these graphs have various applications in our real lives, this includes flight paths, social networks like friend groups and puzzle games. 
In this project our main focus would be on complete graphs.\\
\\
 I started preparing researching by starting with firstly this stage, understanding what a simple graph is, from a mathematical view point and how it can be understood from a computer science view point.
  From graphs we get to the Ramsey theory which is a problem relating to graphs theory and very hard to solve.
   Ramsey theory tries to understand how order is found in chaos. 
   And from my understanding is Ramsey numbers are hard to find because the graphs that are generated depending on the vertices grow super-exponentially by a factor of $2^{n^2}$ this is the reason why Ramsey numbers of diagonals over 4 are not yet found.\\
  
\section*{Sub task A}
\subsection*{Graph Theory}
Graph- A graph $G = (V,E)$ is a set of objects called vertices $V$ and a pair of objects taken from $V$ called edges.\\
$V = \{v_1,v_2,v_3....\}$\\
$E = \{e_{12},e_{13}...\}$\\\\
Neighbours- Two vertices that are connected by an edge\\\\
Degree - Number of edges connected to a vertex\\\\
Directed Graph - edges have orientation\\\\
Undirected Graph -  edges have no orientation\\\\
Complete Graph $K_n$
\begin{itemize}
	\item has n vertices and all possible edges 
	\item has degrees n-1
	\item number of edges is $\frac{n(n-1)}{2}$
\end{itemize}
Adjacent Matrix\\
$$\begin{tikzpicture}
	\graph {
		1 -- {2};
		2--{3};
		3--{1};
		4--{3};

	};
\end{tikzpicture}$$
$$\begin{tabular}{c|c|c|c|c}
		&1&2&3&4\\\hline
		1&0&1&1&0\\\hline
		2&1&0&1&0\\\hline
		3&1&1&0&1\\\hline
		4&0&0&1&0\\\hline
\end{tabular}$$'
Adjacent List \\\\
\begin{center}
1 $\rightarrow$(2,3)\\
2 $\rightarrow$(1,3)\\
3 $\rightarrow$(1,2,4)\\
4 $\rightarrow$(3)\end{center}
\underline{Several applications of Graphs}\\\\
\begin{itemize}
	\item Mappings/Navigation (Uber)
	\item Social Network
	\item Puzzle games (Soduku, Chess)
\end{itemize}
\newpage
\subsection*{Ramsey Theory}
Named after mathematician Frank Ramsey, who first proved a problem in combinatorics.
The theory state that a monochromatic cliques in any edge labeling of large enough complete graph, or for two colours say red(r) and blue(b) be any two positive integers, the theorem states that there's a least positive integer $R(r,b)$ such that for which every blue-red edge colouring of the complete graph on $R(r,b)$ vertices contains a blue clique on r vertices or a red clique on b vertices.\\\\
\begin{itemize}
	\item In a complex and large enough system a pattern can almost be found
	\item There is order in chaos
	\item Made up of complete graphs
\end{itemize}
\subsection*{Ramsey Numbers}
Is the minimum number of vertices $n = R(r,b)$ such that all undirected simple graph of order r contains a group of order b or independent set of order n
\newpage
\section*{Sub Task B}
\begin{enumerate}
	\item n Represents the minimum number such that the complete graph $k_n$ gives for every blue-red colouring of $k_n$ a blue-coloured $k_l$ or a red-coloured $k_t$.\\\\
	When k/l or k and l are increased, we get a bigger n, this shows that n depends on k and l\\\\
	Example(The party problem)\\\\
	How many people(n) are needed to be invited to a party to guarantee that either k people know each other or l people are strangers 
	\item 
	Starting from the known Ramsey Numbers, k and l = 1, only considering the diagonal ones where k=l\\\\
	R(1,1)=1\\
	R(2,2)=2\\
	R(3,3) = 6\\
	R(4,4)=18\\
Showing that the n increases with an increase in both k and l
\end{enumerate}
\subsection*{Summary}
Firstly what i did was use the links provided to understand the theories given namely Graph Theory and Ramsey Theory.
Understanding concept of graphs from a mathematical point of view together with computer science point of view.
We explored applications in different fields and how they are incredibly not easy to compute.
And understood that there exists order in chaos.
\newpage
\section*{Task 2}

\subsection*{Introduction}
Main idea is that graphs can have different orientations but same structure this is called homomorphic graphs.
 So what i understand in this task is to see how we can get different structures of graphs from making orientations with the vertices and edges.
  Each vertices in different graphs say graph A and graph B must first have same about of vertices that can be arranged in any orientation, same degrees and with same number of neighbours in other words this can be thought of as same graphs that have same structural properties. 
  Its more about fitting one graph into the other by shifting vertices and edges but still preserving the same structure. \\\\
So for this task I was able to draw different graphs starting with graph of only one vertices having no edges to going to in increasing manner from 2, 3 and 4 vertices.
 What happened is i explored different types of orientations and how the number of graphs depends on the number $2^{\left( \frac{n^2-n}{n}\right)}$, this shows that the number of graphs increases super exponentially by increasing n. 
 Although when we get to graphs having different structures(Homomorphic graphs) I was able to notice that these do not grow as much as the number of graphs increases. 
\subsection*{\underline{Sub-task A}}
\begin{enumerate}
	\item A graph homomorphism f from a graph $G = (V(G),E(G))$ to a graph $H =(V(H),E(H))$, f $: G \rightarrow H$ is a function from V(G) to V(H) that preserves edges.
\end{enumerate}
\subsection*{\underline{Sub-task B}}
\begin{enumerate}
	
	\item Let $G_1 = (v_i(G),e_i(G))$ represent a graph.\newline
	then $v_i(G) \sim v_i(G)$ and $e_i(G) \sim e_i(G)$(by definition)\newline
	$\implies G\sim G$  
	
	\item
	Let $G = (v_i(G),e_i(G))$ represent a graph.\newline
	$H = (v_i(H),e_i(H))$ also represent a graph.\newline
	then $v_i(G) \sim v_i(H)$ and $e_i(G) \sim e_i(H)$(from the given condition)\newline
	Hence $ G\sim H$  
	\item 	Let $G = (v_i(G),e_i(G))$ represent a graph.\newline
	$H = (v_i(H),e_i(H))$ also represent a graph.\newline
 and	$K = (v_i(K),e_i(K))$ represent a graph.\newline
	then if $v_i(G) \sim v_i(H)$ and $e_i(G) \sim e_i(H)$(from the given condition)\newline
	And  $v_i(H) \sim v_i(K)$ and $e_i(H) \sim e_i(K)$(from the given condition)\newline
	$\implies v_i(G)\sim v_i(K)$ with $e_i(G) \sim e_i(K)$ \newline
	We would then have 
	$\implies G\sim K$ 
	 \end{enumerate}\includepdf[pages={4,3,2,1}]{my_labeled_graphs.pdf}
	 \newpage
	So what i started with calculating the amount of graph that I need to draw depending on n, using the equation $2^{ \frac{\left(n^2-n\right)}{n}}$,\\\\
	Then i started to draw the vertices of n=1.
	 Which we get the number of graphs would be 1, so there would be a number of 1 vertices and 0 edges since we can connect it to any other vertex.
	 \\\\Then going to n = 2 we have only 2 graph orientations. 
	 The first orientation all vertices did not have any edges, where the other orientation had all edges drawn from them, this implies to each vertex is connected to each vertex of the graph.\\\\ 
	So going to n=3 we get the number of orientations we have 8 different ways in which this can be arranged.
	 I started with all the edges connected to other ones with each one possible then seeing each of the graphs can be arranged,so starting by only any two other vertices with an edge and try to make sure that the "completed graph" drawn first is complete by joining any 2 random vertices this would only result in only 3 ways.
	 Then moving on to 2 edges, so what i did was from the previous graphs obtained with only one edge was extend each of them only once by an edge connecting them to another vertex which did not have any edge, doing this i had 3 more ways and finally i was done with n=3.\\\\
	Going to n=4 we have the first one where there is no edges connected, and after draw all possible connections.
	 In order to find all different types of graphs that can be obtained, after pair only 2 vertices and this can be 6 using the reference of the full complete graph. 
	 Then from there i took each graph and expanded all 5 different combinations which resulted in 6$\times 5$ = 30 graphs with 2 edges connected and from there only took the ones that are not duplicated which resulted in 15 more graphs.
	  Then from there i extended each of the 15 graphs since they can have any 4 more different ways in which they can complete the graph, this created a way in which i can get to 64 graphs of 4 vertices graph.

\subsection*{Summary}
So for this task i was able to understand what a graph homomorphism is, in the context of complete graph.
 What i did was find different classes of graph with same vertices by drawing each individual orientation of these vertices leading to a combination of them. 
 How i found these homomorphic graphs, i was able to map each vertex in one graph and try to ensure that they are all mapping to one vertices, and also it would have the same amount of neighbours.\newpage For this part of the project all we have to do is find labels for our graphs. 
 In other words find a way in which we can count, say if we have 4 graphs we should be able to identify each graph and match it with its unique number depending on what we agree as our reference of labeling. 
 If we consider the adjacency matrix we know that the relationship between the vertices which can be considered as a binary encoding, because the vertices can either be neighbours or not(i.e 1 or 0).
So we see that this encoding can be a way to represent our labels, but it would be confusing if we do not agree on a which we are going to count from our adjacency matrix, so im going to include an example. 
Say we have a 4 x 4 adjacency matrix,

\begin{equation}
\begin{pmatrix}
	0&0_5&1_4&1_3\\
	..&0&0_2&1_1\\
	..&..&0&1_0\\
	..&..&..&0
\end{pmatrix}
\end{equation}
and the horizontal(binary) matrix in which we are going to use to count/label the graphs so this is given by how i have numbered the upper triangular matrix in the adjacent matrix.\begin{equation}
	\begin{pmatrix}
		0_5&1_4&1_3&0_2&1_1&1_0
	\end{pmatrix}
\end{equation}
 so converting this to binary we have $2^0+2^1+0+2^3+2^4+0$=1+2+8+16=27.\newline
 This means our 27th graph when we use the 0-th index we have that this list in which the vertices are connected is given by $\{(1,3),(1,4),(2,4),(3,4)\}$\newline
 The following graphs are shown in where they are labeled in binary
\includepdf[pages={1,2,3,4}]{binary_labeled_graphs.pdf}
Then for the second part we had to group these labeled graphs in a which they can be in their own homomorphic groups like in task 2.
 Here the only challenge would trying to find groups that have the same orientations, although 2 can show which graphs have how many certain edges the only problem would be ensuring that they have the same orientation.
  So i was able to find these groups and also ensure that they are correctly numbered.
\includepdf[pages={4,3,2,1}]{binary_homomorphic_groups.pdf}
 We basically found a way to draw our graphs in a way which we can identify each individual graph using Binary counting. This is the efficient way so far that we can understand.\newpage
 \section*{first\_draft\_graph\_code.py}
Then for putting all these graphs in python, i had to find a way in which i can define numbers in binary. 
Using the function "bin(num)".
Then from there i was able to split this binary number into a string, so that i can be able to return it as vector.
Then this vector can be put in the adjacency matrix that i would need to draw the graph.
The reason this was done was in order to identify the vertices that are going to be connected to each other according to the adjacency matrix.
Then what i had to do was define the vertices on a graph using the "matplotlib.pyplot" to draw points on a Cartesian plane. 
To get the vertices i just had to eye ball and ensure that the differences between them is the same.
Then to get the edges i had to define a straight line graph between the vertices, this was either horizontal, vertical and diagonal lines between them.


$$\includegraphics[scale=0.5]{first_draft_graphs_code/figure_10.png}$$\\
n=2\\
\includegraphics[scale = 0.4]{first_draft_graphs_code/figure_20.png} \includegraphics[scale = 0.4]{first_draft_graphs_code/figure_21.png}
\\
n=3\\
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_30.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_31.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_32.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_33.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_34.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_35.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_36.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_37.png}
\\
n=4\\
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_40.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_41.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_42.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_43.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_44.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_45.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_46.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_47.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_48.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_49.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_410.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_411.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_412.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_413.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_414.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_415.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_416.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_417.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_418.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_419.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_420.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_421.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_422.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_423.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_424.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_425.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_426.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_427.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_428.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_429.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_430.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_431.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_432.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_433.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_434.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_435.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_436.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_437.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_438.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_439.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_440.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_441.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_442.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_443.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_444.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_445.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_446.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_447.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_448.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_449.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_450.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_451.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_452.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_453.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_454.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_455.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_456.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_457.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_458.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_459.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_460.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_461.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_462.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_463.png}
\newpage
\section*{more\_systematic\_graphs.py}
Using the functions from the first draft part, the binary matrix and adjacent matrix functions are used.
Then i extended this by including the vertices because the first part was not a systematic way to draw the vertices.
So what is different about this part of the code is that i used the equation of a circle to define a way in which we can put the vertices.
So in python i defined a function "vertices" that takes in "n" for number of vertices.
Then defined two empty lists in order to add in the lists of x and y values.
x values of a circle are given by $\cos({2\pi \frac{i}{n}})$ this would then be added to the x values list.
This would be the same for the y values only difference is the $\sin({2\pi \frac{i}{n}})$ part only.
Then this function returns x and y values lists.\newline
Going to edges, i created an "edges" function that also takes in n as an input.
It uses the vertices function as a set of x and y values together with adjacency matrix.
Firstly it plots the vertices using the x and y values.
Then when the element in the adjacency matrix is 1 it draws an edge between the vertices.
Using the plt.plot function to plot a line between these vertices.
When the element is 0 it just returns no edge between them. \newline
These functions are part of a function i defined as "Graphs" that takes in n and k for the number of graphs, and returns the plot of edges with vertices.
Then starting with n = 1 we have the following outputs using a loop we get that\newline
n = 1\newline
$$\includegraphics[]{more_systematic_graphs/figure_10.png}$$
n= 2\\
\includegraphics[scale = 0.4]{more_systematic_graphs/figure_20.png} \includegraphics[scale = 0.4]{more_systematic_graphs/figure_21.png}
\\
n=3\\
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_30.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_31.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_32.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_33.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_34.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_35.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_36.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_37.png}
\\
n=4\\
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_40.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_41.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_42.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_43.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_44.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_45.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_46.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_47.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_48.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_49.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_410.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_411.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_412.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_413.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_414.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_415.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_416.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_417.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_418.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_419.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_420.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_421.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_422.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_423.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_424.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_425.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_426.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_427.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_428.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_429.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_430.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_431.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_432.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_433.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_434.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_435.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_436.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_437.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_438.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_439.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_440.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_441.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_442.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_443.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_444.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_445.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_446.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_447.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_448.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_449.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_450.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_451.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_452.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_453.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_454.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_455.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_456.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_457.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_458.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_459.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_460.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_461.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_462.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_463.png}
\newpage
\begin{itemize}
	\item  Adiabatic quantum computing(AQC) started as an approach to solving optimization problems
	\item in AQC the computation proceeds from an initial Hamiltonian whose ground
	state is easy to prepare, to a final Hamiltonian whose
	ground state encodes the solution to the computational problem.
\end{itemize}
\newpage

\section*{Classical Algorithm for finding ramsey numbers}
\subsubsection*{Thinking}
\underline{\centering{Goal:Write code that determines a Ramsey Number}}
\begin{itemize}
	\item i need to verify ramsey numbers
	\item use brute force method to verify if all graphs of n-vertices there will be either red or subgraphs. 
	\item use adjacency matrix code to determine if a rxr matrix of either empty graph or matrix with ones at off diagonal elements and zero at diagonal elements in the adjacency matrix
	\item firstly define the matrix of the complete graph call it blue\_clique, and an empty graph call it red\_clique
	\item create an empty vector this will keep track of which graphs has either a red clique or a blue clique
	\item if the graph in the graph set has either a red / blue clique the element of the graph in the graph set change the element to 1
	\item then use the empty vector to see if for a graph set of n vertices there is a zero in the vector then n is not a ramsey number
\end{itemize}

\begin{enumerate}
	\item Comparison set
	\item write the algorithm used (check online internet) pseudo-code algorithm in the write up
	\item need to implement Ramsey number search 
	\item explain how the recipe works type 
	\item write code as lean as possible to run in cluster
	\item table for different inputs(not complete in my machine )
\end{enumerate}
\%\% firstly starting with defining the graph plots\\
\% \underline{binary vector} - creating a vector of binary string of each graph in the graph set return the binary vector of the string ensuring that the vector has $\left(\frac{n^2-n}{2}\right)$ elements\\\\
\begin{itemize} \item BEGIN FUNCTION binary\_vector(number of vertices, graph number)
\begin{itemize}
	
\item INITIALIZE and Define parameters\\
set\\
n= number of vertices  \\
 m =$\left(\frac{n^2-n}{2}\right)$\\
binary\_vec = zeros(m)\\
binary(n)\\
L = len(binary(n))
\item BEGIN LOOP\\
FOR i FROM 1 to L\\
  \hspace*{0.5cm} DO binary\_vec(m-i-1) = REVERSE(binary)(i)\\
  END LOOP
\end{itemize}
\hspace*{0.5cm}RETURN binary\_vec\\
END FUNCTION\\\\
\%\% create a function that transposes the binary matrix into an empty matrix of n x n\\\\
\item BEGIN FUNCTION adjacency\_matrix(number of vertices,graph number)
\begin{itemize}
\item INITIALIZE and Define parameters\\
n= number of vertices\\
$m = \left(\frac{n^2-n}{2}\right)$\\
$A = zeros(n,n)$\\
b =  binary\_vector(n,graph number)\\
start\_index = 1
\item BEGIN LOOP\\
FOR i = 1 TO n\\
 \hspace*{0.5cm} DO\\
  \hspace*{0.5cm}index\_length = n-1-i\\
 \hspace*{0.5cm} end\_index = start\_index + index\_length\\
 \hspace*{0.5cm} A(i,i+1:) = b(start\_index , end\_index)\\
 \hspace*{0.5cm} start\_index = end\_index\\
END LOOP
 \item BEGIN LOOP\\
 FOR i = 1 TO n\\
 FOR j = 1 TO n\\
 \hspace*{0.5cm} DO A(j,i) = A(i,j)\\
 END LOOP

	RETURN A\\
\hspace*{-1cm}END FUNCTION\\
	\end{itemize}
\%\% create a function to plot graph, this takes in number of vertices and the graph number.\\
\%\% it returns a graph with red edges and blue edges
\item	BEGIN FUNCTION GRAPH(number of vertices , graph number)\\
\begin{itemize}

\item	INITIALIZE\\
	A = adjacency\_matrix\\
	b = binary\_matrix\\
	x = zeros(n)\\
	y = zeros(n)\\
	
	\item BEGIN LOOP\\
	FOR i = 1 TO n\\
	\hspace*{0.5cm} DO\\
	\hspace*{0.5cm} x = cos($\frac{2\pi}{n}i$)\\
	\hspace*{0.5cm}	y = sin($\frac{2\pi}{n}i$)\\
	END LOOP
	\item \hspace*{0.2cm} BEGIN LOOP\\
	\hspace*{0.5cm} FOR i = 1 TO n:\\
	\hspace*{0.5cm} FOR i = j TO n:\\
	\hspace*{0.5cm} DO\\
	\hspace*{1cm} IF A(i,j) = 1\\
\hspace*{1.5cm}	add\_line between points (x[i],x[j]) and (y[i],y[j]) with blue colour\\
\hspace*{1.5cm} add k at center for number of graph\\
\hspace*{1cm}	ELSE  A(i,j) = 0\\
\hspace*{1.5cm}	add\_line between points (x[i],x[j]) and (y[i],y[j]) with red colour\\
	\hspace*{1.5cm} put k for number of graph\\
RETURN PLOT\\
\end{itemize}
END FUNCTION\\\\
\%\% create a function that verifies if all the graphs of n vertices has either a red clique of order r or blue clique of order s\\
\%\% And if a clique does not exist then return the graph that does not contain the clique
\item BEGIN FUNCTION ramsey\_find(number of vertices , r , s)
\begin{itemize}
\item
INITIALIZE\\
n = number of vertices \\
$m = \left(\frac{n^2-n}{2}\right)$ \\
b = binary\_matrix(number of vertices,graph number)\\
A = adjacency\_matrix(number of vertices,graph number)\\
clique = graphs of size r and s 

\item BEGIN LOOP\\
\hspace*{1cm}FOR k = 1 TO $2^{m}$\\
\begin{itemize}
	\item \hspace*{1.5cm}BEGIN LOOP\\
\hspace*{1.5cm} FOR subgraph IN A\\
\hspace*{1.5cm} BEGIN LOOP\\
\hspace*{1.5cm} IF subgraph = size r or size s clique:\\
\hspace*{2cm}CONTINUE to the next graph\\
\hspace*{1.5cm}ELSE \\
\hspace*{2cm}BREAK LOOP\\
\hspace*{1.5cm} END LOOP\\

\end{itemize}
\hspace*{1cm} END k LOOP
\item BEGIN LOOP\\
\hspace*{1cm}IF clique not found\\
\hspace*{1.5cm} PRINT('(n) is a Ramsey Number R(r, s)')\\
\hspace*{1.5cm} PRINT(Graph(n,k))\\
\hspace*{1.5cm} BREAK LOOP\\
\hspace*{1cm}ELSE \\
\hspace*{1.5cm} return '(n) is a Ramsey Number R(r, s)'\\
 END LOOP\\
\end{itemize}
END FUNCTION
\end{itemize}
\newpage
\%\%\% Goal\\
\%\%\% Create a function that searches for ramsey numbers \\
\begin{itemize}
\item FUNCTION Ramsey\_Number(r : INTEGER , s : INTEGER)\\
\begin{itemize}
\item  n $\leftarrow$ 2 (*starting at 2 vertices*)
\item N $\leftarrow$ total\_graphs(n)
	\item A $\leftarrow$ adjacency\_matrix(n,graph)
\item G $\leftarrow$ draw\_graph(n,graph)
\item comb1 $\leftarrow$choose different vertex combination
\item comb2 $\leftarrow$choose different vertex combination
\item WHILE TRUE DO:
\begin{itemize}
\item FOR graph $\leftarrow$ 1 TO N:


\begin{itemize}
\item FOR vertex in comb1:
\item A[vertex,vertex+1]
\section*{Pseudocode}
\end{itemize}
\end{itemize}
\end{itemize}
\end{itemize}
\newpage
\RestyleAlgo{ruled}
\SetKwFunction{Fnumber}{total\_edges} % Defines a function named 'AddNumbers' that can be called with \
\SetKwFunction{Fdraw}{fill\_bits} % Defines another function
\SetKwFunction{Flabel}{label\_graph} % Defines another function
\SetKwFunction{Fdraw}{draw\_graph} % Defines another function
\SetKwFunction{Fempty}{empty\_graph} % Defines a function named 'AddNumbers' that can be called with \
\SetKwFunction{Fcomplete}{complete\_graph} % Defines another function
\SetKwFunction{Freverse}{Reverse} % Defines another function
\SetKwFunction{Fbinary}{binary\_string} % Defines another function
\SetKwFunction{Ftotal}{total\_graphs} % Defines another function
\SetKwComment{Comment}{/* }{ */}
\begin{itemize}
\item This function verifies the graphs of n vertices has either a red clique of order r or blue clique of order s\\
And if a clique does not exist then return the graph that does not contain the clique

\begin{algorithm}[hbt!]
	\caption{Main Function}\label{alg:two}
	\DontPrintSemicolon
	\KwIn{integers r and s}
	\KwOut{minimum n that has r or s size clique} % This command now works
	
	\Begin{
		Set\; 
		$n \gets 1$  \Comment{starting with 1 vertex}\;
		$m \leftarrow$ \Fnumber{$n$}\;
		$\N \gets \Ftotal{n}$\;
		$red\_clique \gets$\Fempty{$r$}\;
		$blue\_clique \gets $ \Fcomplete{$s$}\;
		plot $\gets$ \Fdraw{$n,k$} \;
		$A \gets$ \Flabel{$n,k$}\;
		\textbf{repeat}\;{
			\For{$k$ from 1 to $2^m$} {
				\If{A has red clique or blue clique}{
					 \textbf{continue}
				}
				\Else{
					 return plot\;\textbf{break}
				}

			}
			
			\If{one graph has no clique}{n $\gets$ n+1}
		}
		
		\textbf{until} all graphs contain clique % This command now works
	}
\end{algorithm}
\item create a function that labels graphs
\begin{algorithm}[H]
	
	\DontPrintSemicolon
	\KwIn{integers $n$,k}\Comment*[r]{n is the number of vertices and k represents the graph number}\;
	\KwOut{graph\_label}
	\Comment{This function labels all the graphs in the graph set}
	\Begin{
		$m \leftarrow$ \Fnumber{$n$}\; % Calling the previously defined function
		$b \leftarrow$  binary\_string(n,k)\\
		adj $\leftarrow$ zeros(n,n)\;
		N = \Ftotal{$n$}\;
		\For{ i to $N$}{fill\_bits(adj,b)}
		\KwRet adj\;
	}
\caption{graph\_label(n,k) Function}
\end{algorithm}

\item create a function to plot graph
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{integers $n$,k}\Comment*[r]{n is the number of vertices and k represents the graph number}\;
	\KwOut{graph\_plot}
	\Comment{This function returns a plot of the graph using the graph labels }
	\Begin{
		$m \leftarrow$ \Fnumber{$n$}\; % Calling the previously defined function
		A $\leftarrow$ \Flabel{n,k}\\
		\For{ i=1 to n}{\For{j =1 to n}{\If{A[i,j]=1 }{add edge}\Else{add red edge}}}
		\KwRet plot\;
	}
	\caption{draw\_label(n,k) Function}
\end{algorithm}


\item This function fills a matrix with the binary vector

\begin{algorithm}[H]
	\DontPrintSemicolon
\KwIn{matrix $A$, vector $b$}
\KwOut{A filled with elements of b}
\Comment{This function fills upper element of the A matrix using elements of b}\;
\Comment{Assumption the number of elements in the upper matrix of A is equal to number of elements in b}
	\Begin{
		start $\gets$ 1 \Comment{starting point of the b vector}\;
		
		$n \leftarrow $ length(A)\;

		
		\For{i 1 to n}{length\_cut $\gets$ n-i \Comment{this is the number of elements in the row}\;
				end $\gets$ start + length\_cut \Comment{the cut off at which the b vector must stop}
				A[i,i+1] = b[start, end] \;
			start $\gets$ end \Comment{update the starting point after each iteration}}\;
			\For{i 1 to n}{\For{i 1 to n}{A[j,i]=A[i,j]}\Comment{This ensures that the matrix is symmetric}}
		\KwRet $A$\;
	}
	\caption{fill\_bits(A, b) Function}
\end{algorithm}
\item Create a function that returns the binary vector of a graph in the graph set.\\
This ensures that the binary string can have total number of edges so that each possible edge can be accounted for in the adjacency matrix.
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{integers $n$, $k$}
	\KwOut{binary string of k}
	\Begin{
		
		$m \gets \frac{n^2-n}{2}$\;
		$b$ $\gets$ zeros(m) \Comment*[r]{ensures that the binary string can have total number of edges}\;
		graph\_number $\gets$ binary(k)\;
		\For{edge 1 to m }{b[m+1-edge] = Reverse(graph\_number)[edge]\Comment*[r]{fills the binary vector using the binary string} } \
		\KwRet $b$\;
	}
	\caption{binary\_string(n,k) Function}
\end{algorithm}
\item This function calculates the possible edges in an n vertex graph
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{An integer $n$}
	\KwOut{Returns total number of edges}
	\Begin{
		
		$m \leftarrow \frac{n^2-n}{2}$\; \Comment{given n we have ${\frac{n^2-n}{2}}$ possible number of graphs}
		\KwRet $m$\;
	}
	\caption{total\_edges(n) Function}
\end{algorithm}
\item This function calculates the total graph in an n vertex
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{An integer $n$}
	\KwOut{Returns total number of graphs}
	\Begin{
		
		
		$N \leftarrow \Fnumber{n}$\; \Comment{given n we have $^{\frac{n^2-n}{2}}$ possible number of graphs}
		\KwRet $2^N$\;
	}
\end{algorithm}
\item This function is for reversing vectors
\begin{algorithm}[H]
		\Comment{The function reverses the vector by swapping elements}
	\DontPrintSemicolon
	\KwIn{vector v}
	\KwOut{reverse of the vector}
\Begin{

	$n \leftarrow \text{length}(v)$\;
	\For{$i$ from 1 to $\lfloor n/2 \rfloor$}{
		\Comment{Swap the element at position i with the element at position n-i+1}
		temp $\leftarrow v[i]$\;
		$v[i] \leftarrow v$[n-i+1]\;
		$v$[n-i+1]$ \leftarrow temp$\;
	}
	\KwRet $v$\;
}

	\caption{Reverse(v) Function}
\end{algorithm}
\item This function is to create an empty graph label
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{An integer $r$}
	\KwOut{empty graph with no edges}
	\Begin{
		
		$clique \leftarrow $ zeros(r,r)\;
		\KwRet $clique$\;
	}
	\caption{empty\_graph(r) Function}
\end{algorithm}
\item This function returns the complete graph
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{An integer $r$}
	\KwOut{complete graph with edges}
	\Begin{
		
		$clique \leftarrow $ ones(r,r)-identity(r,r)\;
		\KwRet $clique$\;
	}
	\caption{complete\_graph(r) Function}
\end{algorithm}
\end{itemize}
\newpage
\subsubsection*{Time Taken for to verify known ramsey numbers}
\begin{table}[hbt!]
	\centering
	\begin{adjustbox}{max width=\textwidth}
		\begin{tabular}{| r | c |}
	\toprule
	\multicolumn{1}{|c|}{Ramsey Number} & Time Taken(s) \\
	\midrule
	\textbf{R(2,2) = 2} & $2.942 \times 10^{-4}$ \\
	\hline
	\textbf{R(2,3) = 3} & $9.022 \times 10^{-4}$ \\
	\hline
	\textbf{R(2,4) = 4} & $8.728 \times 10^{-3}$ \\
	\hline
	\textbf{R(2,5) = 5} & $1.223 \times 10^{-1}$ \\
	\hline
	\textbf{R(2,6) = 6} & 2.756 \\
	\hline
	\textbf{R(2,7) = 7} & $1.722 \times 10^{2}$ \\
	\hline
	\textbf{R(2,8) = 8} & $4.396 \times 10^{4}$ \\
	\hline
	\textbf{R(2,9) = 9} & \\
	\hline
	\textbf{R(2,10) = 10} & \\
	\hline
	\textbf{R(3,3) = 6} & 8.671 \\
	\hline
	\textbf{R(3,4) = 9} & \\
	\hline
	\textbf{R(3,5) = 14} & \\
	\hline
	\textbf{R(3,6) = 18} & \\
	\hline
	\textbf{R(3,7) = 23} & \\
	\hline
	\textbf{R(4,4) = 18} & \\
	\hline
	\textbf{R(4,5) = 25} & \\
	\bottomrule
\end{tabular}
	\end{adjustbox}
	\caption{Ramsey Number Calculation Times}
	\label{tab:ramsey_times}
\end{table}
\newpage
\subsubsection*{What i notice}
\begin{enumerate}
\item The runtime for finding each ramsey number increases exponentially
\item The runtime is lower when instead of finding $R(s,r)$ when $s<r$. 
\end{enumerate}
\section*{Quantum algorithm}

\begin{itemize}
	\item VQE
	\item Grover adaptive search(QUBO highest term quadratic)
	\item Use order reduction
\end{itemize}
\subsection*{Grover's Algorithm}
\begin{itemize}
\item Search Algorithm 
\item Can search through unordered list
\item uses superposition and interference to search
\item offers a quadratic speed up 
\begin{itemize}
\item If a list has $N$ elements the algorithm would have $\mathcal{O}(\sqrt{N})$ iterations
\item for a list with 16 elements there would be 4 qubits required
\end{itemize}
\subsubsection*{Procedure}
\begin{itemize}
	\item Apply the oracle
	\item Apply the Hadamard Gate to turn all states into superposition
\end{itemize}
\end{itemize}
\subsubsection*{Pseudocode For Grover's Algorithm}
\subsubsection*{Difference between Grover and VQE}
\begin{table}[hbt!]
	\centering
	\caption{Comparison of Grover's Algorithm and VQE}
	\label{tab:grover_vqe_comparison}
	\begin{adjustbox}{max width=\textwidth}
		\begin{tabular}{|c|c|c|}
			\toprule
		
			& \textbf{Grover's Algorithm} & \textbf{VQE} \\
			\midrule
			\textbf{Primary Goal} & Unstructured search & Find ground state energy \\
			\hline
			\textbf{Optimization Type} & Search-based & Energy minimization \\
			\hline
			\textbf{Uses Hamiltonian} &uses an oracle & Yes \\
			\hline
			\textbf{Theoretical Speedup} & Quadratic ($O(\sqrt{N})$) & Not specified\\
	
			\hline
			\textbf{Initialization} & Initialize states to superposition & Also initializes states at the beginning of algorithm  \\
			\bottomrule
		\end{tabular}
	\end{adjustbox}
\end{table}
\end{document}