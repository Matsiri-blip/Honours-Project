\documentclass{Assignment}
\usepackage{indentfirst}
\usepackage[linesnumbered,lined,boxed,commentsnumbered]{algorithm2e}
\usepackage{booktabs}   % For \toprule, \midrule, \bottomrule
\usepackage{adjustbox}  % For the adjustbox environment
\usepackage{graphicx}   % Recommended for figures and tables
\bibliographystyle{unsrtnat}
\usepackage{url}
\usepackage{tikz}
\usepackage{pdfpages}
\usepackage{booktabs}       % For professional-looking tables (\toprule, \midrule, \bottomrule)
\usepackage{adjustbox}      % For table adjustment if it's too wide
\usepackage{textcomp}       % For \textsuperscript
\usetikzlibrary{graphs}
\title{Graph Theory}
\begin{document}

\section*{Task 1}
\subsection*{Introduction}
Main idea of this project is to understand graphs  as a mathematical set and also in a computer science perspective. 
Generally graphs are thought of as usually thought of as functions that are made of axis i.e x and y, and well the z-th axis.
But mathematicians usually study graphs made up of set of vertices(points) with edges(curves) connecting these vertices.
And these graphs have various applications in our real lives, this includes flight paths, social networks like friend groups and puzzle games. 
In this project our main focus would be on complete graphs.\\
\\
 I started preparing researching by starting with firstly this stage, understanding what a simple graph is, from a mathematical view point and how it can be understood from a computer science view point.
  From graphs we get to the Ramsey theory which is a problem relating to graphs theory and very hard to solve.
   Ramsey theory tries to understand how order is found in chaos. 
   And from my understanding is Ramsey numbers are hard to find because the graphs that are generated depending on the vertices grow super-exponentially by a factor of $2^{n^2}$ this is the reason why Ramsey numbers of diagonals over 4 are not yet found.\\
  
\section*{Sub task A}
\subsection*{Graph Theory}
Graph- A graph $G = (V,E)$ is a set of objects called vertices $V$ and a pair of objects taken from $V$ called edges.\\
$V = \{v_1,v_2,v_3....\}$\\
$E = \{e_{12},e_{13}...\}$\\\\
Neighbours- Two vertices that are connected by an edge\\\\
Degree - Number of edges connected to a vertex\\\\
Directed Graph - edges have orientation\\\\
Undirected Graph -  edges have no orientation\\\\
Complete Graph $K_n$
\begin{itemize}
	\item has n vertices and all possible edges 
	\item has degrees n-1
	\item number of edges is $\frac{n(n-1)}{2}$
\end{itemize}
Adjacent Matrix\\
$$\begin{tikzpicture}
	\graph {
		1 -- {2};
		2--{3};
		3--{1};
		4--{3};

	};
\end{tikzpicture}$$
$$\begin{tabular}{c|c|c|c|c}
		&1&2&3&4\\\hline
		1&0&1&1&0\\\hline
		2&1&0&1&0\\\hline
		3&1&1&0&1\\\hline
		4&0&0&1&0\\\hline
\end{tabular}$$'
Adjacent List \\\\
\begin{center}
1 $\rightarrow$(2,3)\\
2 $\rightarrow$(1,3)\\
3 $\rightarrow$(1,2,4)\\
4 $\rightarrow$(3)\end{center}
\underline{Several applications of Graphs}\\\\
\begin{itemize}
	\item Mappings/Navigation (Uber)
	\item Social Network
	\item Puzzle games (Soduku, Chess)
\end{itemize}
\newpage
\subsection*{Ramsey Theory}
Named after mathematician Frank Ramsey, who first proved a problem in combinatorics.
The theory state that a monochromatic cliques in any edge labeling of large enough complete graph, or for two colours say red(r) and blue(b) be any two positive integers, the theorem states that there's a least positive integer $R(r,b)$ such that for which every blue-red edge colouring of the complete graph on $R(r,b)$ vertices contains a blue clique on r vertices or a red clique on b vertices.\\\\
\begin{itemize}
	\item In a complex and large enough system a pattern can almost be found
	\item There is order in chaos
	\item Made up of complete graphs
\end{itemize}
\subsection*{Ramsey Numbers}
Is the minimum number of vertices $n = R(r,b)$ such that all undirected simple graph of order r contains a group of order b or independent set of order n
\newpage
\section*{Sub Task B}
\begin{enumerate}
	\item n Represents the minimum number such that the complete graph $k_n$ gives for every blue-red colouring of $k_n$ a blue-coloured $k_l$ or a red-coloured $k_t$.\\\\
	When k/l or k and l are increased, we get a bigger n, this shows that n depends on k and l\\\\
	Example(The party problem)\\\\
	How many people(n) are needed to be invited to a party to guarantee that either k people know each other or l people are strangers 
	\item 
	Starting from the known Ramsey Numbers, k and l = 1, only considering the diagonal ones where k=l\\\\
	R(1,1)=1\\
	R(2,2)=2\\
	R(3,3) = 6\\
	R(4,4)=18\\
Showing that the n increases with an increase in both k and l
\end{enumerate}
\subsection*{Summary}
Firstly what i did was use the links provided to understand the theories given namely Graph Theory and Ramsey Theory.
Understanding concept of graphs from a mathematical point of view together with computer science point of view.
We explored applications in different fields and how they are incredibly not easy to compute.
And understood that there exists order in chaos.
\newpage
\section*{Task 2}

\subsection*{Introduction}
Main idea is that graphs can have different orientations but same structure this is called homomorphic graphs.
 So what i understand in this task is to see how we can get different structures of graphs from making orientations with the vertices and edges.
  Each vertices in different graphs say graph A and graph B must first have same about of vertices that can be arranged in any orientation, same degrees and with same number of neighbours in other words this can be thought of as same graphs that have same structural properties. 
  Its more about fitting one graph into the other by shifting vertices and edges but still preserving the same structure. \\\\
So for this task I was able to draw different graphs starting with graph of only one vertices having no edges to going to in increasing manner from 2, 3 and 4 vertices.
 What happened is i explored different types of orientations and how the number of graphs depends on the number $2^{\left( \frac{n^2-n}{n}\right)}$, this shows that the number of graphs increases super exponentially by increasing n. 
 Although when we get to graphs having different structures(Homomorphic graphs) I was able to notice that these do not grow as much as the number of graphs increases. 
\subsection*{\underline{Sub-task A}}
\begin{enumerate}
	\item A graph homomorphism f from a graph $G = (V(G),E(G))$ to a graph $H =(V(H),E(H))$, f $: G \rightarrow H$ is a function from V(G) to V(H) that preserves edges.
\end{enumerate}
\subsection*{\underline{Sub-task B}}
\begin{enumerate}
	
	\item Let $G_1 = (v_i(G),e_i(G))$ represent a graph.\newline
	then $v_i(G) \sim v_i(G)$ and $e_i(G) \sim e_i(G)$(by definition)\newline
	$\implies G\sim G$  
	
	\item
	Let $G = (v_i(G),e_i(G))$ represent a graph.\newline
	$H = (v_i(H),e_i(H))$ also represent a graph.\newline
	then $v_i(G) \sim v_i(H)$ and $e_i(G) \sim e_i(H)$(from the given condition)\newline
	Hence $ G\sim H$  
	\item 	Let $G = (v_i(G),e_i(G))$ represent a graph.\newline
	$H = (v_i(H),e_i(H))$ also represent a graph.\newline
 and	$K = (v_i(K),e_i(K))$ represent a graph.\newline
	then if $v_i(G) \sim v_i(H)$ and $e_i(G) \sim e_i(H)$(from the given condition)\newline
	And  $v_i(H) \sim v_i(K)$ and $e_i(H) \sim e_i(K)$(from the given condition)\newline
	$\implies v_i(G)\sim v_i(K)$ with $e_i(G) \sim e_i(K)$ \newline
	We would then have 
	$\implies G\sim K$ 
	 \end{enumerate}\includepdf[pages={4,3,2,1}]{my_labeled_graphs.pdf}
	 \newpage
	So what i started with calculating the amount of graph that I need to draw depending on n, using the equation $2^{ \frac{\left(n^2-n\right)}{n}}$,\\\\
	Then i started to draw the vertices of n=1.
	 Which we get the number of graphs would be 1, so there would be a number of 1 vertices and 0 edges since we can connect it to any other vertex.
	 \\\\Then going to n = 2 we have only 2 graph orientations. 
	 The first orientation all vertices did not have any edges, where the other orientation had all edges drawn from them, this implies to each vertex is connected to each vertex of the graph.\\\\ 
	So going to n=3 we get the number of orientations we have 8 different ways in which this can be arranged.
	 I started with all the edges connected to other ones with each one possible then seeing each of the graphs can be arranged,so starting by only any two other vertices with an edge and try to make sure that the "completed graph" drawn first is complete by joining any 2 random vertices this would only result in only 3 ways.
	 Then moving on to 2 edges, so what i did was from the previous graphs obtained with only one edge was extend each of them only once by an edge connecting them to another vertex which did not have any edge, doing this i had 3 more ways and finally i was done with n=3.\\\\
	Going to n=4 we have the first one where there is no edges connected, and after draw all possible connections.
	 In order to find all different types of graphs that can be obtained, after pair only 2 vertices and this can be 6 using the reference of the full complete graph. 
	 Then from there i took each graph and expanded all 5 different combinations which resulted in 6$\times 5$ = 30 graphs with 2 edges connected and from there only took the ones that are not duplicated which resulted in 15 more graphs.
	  Then from there i extended each of the 15 graphs since they can have any 4 more different ways in which they can complete the graph, this created a way in which i can get to 64 graphs of 4 vertices graph.

\subsection*{Summary}
So for this task i was able to understand what a graph homomorphism is, in the context of complete graph.
 What i did was find different classes of graph with same vertices by drawing each individual orientation of these vertices leading to a combination of them. 
 How i found these homomorphic graphs, i was able to map each vertex in one graph and try to ensure that they are all mapping to one vertices, and also it would have the same amount of neighbours.\newpage For this part of the project all we have to do is find labels for our graphs. 
 In other words find a way in which we can count, say if we have 4 graphs we should be able to identify each graph and match it with its unique number depending on what we agree as our reference of labeling. 
 If we consider the adjacency matrix we know that the relationship between the vertices which can be considered as a binary encoding, because the vertices can either be neighbours or not(i.e 1 or 0).
So we see that this encoding can be a way to represent our labels, but it would be confusing if we do not agree on a which we are going to count from our adjacency matrix, so im going to include an example. 
Say we have a 4 x 4 adjacency matrix,

\begin{equation}
\begin{pmatrix}
	0&0_5&1_4&1_3\\
	..&0&0_2&1_1\\
	..&..&0&1_0\\
	..&..&..&0
\end{pmatrix}
\end{equation}
and the horizontal(binary) matrix in which we are going to use to count/label the graphs so this is given by how i have numbered the upper triangular matrix in the adjacent matrix.\begin{equation}
	\begin{pmatrix}
		0_5&1_4&1_3&0_2&1_1&1_0
	\end{pmatrix}
\end{equation}
 so converting this to binary we have $2^0+2^1+0+2^3+2^4+0$=1+2+8+16=27.\newline
 This means our 27th graph when we use the 0-th index we have that this list in which the vertices are connected is given by $\{(1,3),(1,4),(2,4),(3,4)\}$\newline
 The following graphs are shown in where they are labeled in binary
\includepdf[pages={1,2,3,4}]{binary_labeled_graphs.pdf}
Then for the second part we had to group these labeled graphs in a which they can be in their own homomorphic groups like in task 2.
 Here the only challenge would trying to find groups that have the same orientations, although 2 can show which graphs have how many certain edges the only problem would be ensuring that they have the same orientation.
  So i was able to find these groups and also ensure that they are correctly numbered.
\includepdf[pages={4,3,2,1}]{binary_homomorphic_groups.pdf}
 We basically found a way to draw our graphs in a way which we can identify each individual graph using Binary counting. This is the efficient way so far that we can understand.\newpage
 \section*{first\_draft\_graph\_code.py}
Then for putting all these graphs in python, i had to find a way in which i can define numbers in binary. 
Using the function "bin(num)".
Then from there i was able to split this binary number into a string, so that i can be able to return it as vector.
Then this vector can be put in the adjacency matrix that i would need to draw the graph.
The reason this was done was in order to identify the vertices that are going to be connected to each other according to the adjacency matrix.
Then what i had to do was define the vertices on a graph using the "matplotlib.pyplot" to draw points on a Cartesian plane. 
To get the vertices i just had to eye ball and ensure that the differences between them is the same.
Then to get the edges i had to define a straight line graph between the vertices, this was either horizontal, vertical and diagonal lines between them.


$$\includegraphics[scale=0.5]{first_draft_graphs_code/figure_10.png}$$\\
n=2\\
\includegraphics[scale = 0.4]{first_draft_graphs_code/figure_20.png} \includegraphics[scale = 0.4]{first_draft_graphs_code/figure_21.png}
\\
n=3\\
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_30.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_31.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_32.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_33.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_34.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_35.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_36.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_37.png}
\\
n=4\\
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_40.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_41.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_42.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_43.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_44.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_45.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_46.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_47.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_48.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_49.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_410.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_411.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_412.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_413.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_414.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_415.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_416.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_417.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_418.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_419.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_420.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_421.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_422.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_423.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_424.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_425.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_426.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_427.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_428.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_429.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_430.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_431.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_432.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_433.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_434.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_435.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_436.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_437.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_438.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_439.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_440.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_441.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_442.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_443.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_444.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_445.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_446.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_447.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_448.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_449.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_450.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_451.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_452.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_453.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_454.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_455.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_456.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_457.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_458.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_459.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_460.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_461.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_462.png}
\includegraphics[scale = 0.5]{first_draft_graphs_code/figure_463.png}
\newpage
\section*{more\_systematic\_graphs.py}
Using the functions from the first draft part, the binary matrix and adjacent matrix functions are used.
Then i extended this by including the vertices because the first part was not a systematic way to draw the vertices.
So what is different about this part of the code is that i used the equation of a circle to define a way in which we can put the vertices.
So in python i defined a function "vertices" that takes in "n" for number of vertices.
Then defined two empty lists in order to add in the lists of x and y values.
x values of a circle are given by $\cos({2\pi \frac{i}{n}})$ this would then be added to the x values list.
This would be the same for the y values only difference is the $\sin({2\pi \frac{i}{n}})$ part only.
Then this function returns x and y values lists.\newline
Going to edges, i created an "edges" function that also takes in n as an input.
It uses the vertices function as a set of x and y values together with adjacency matrix.
Firstly it plots the vertices using the x and y values.
Then when the element in the adjacency matrix is 1 it draws an edge between the vertices.
Using the plt.plot function to plot a line between these vertices.
When the element is 0 it just returns no edge between them. \newline
These functions are part of a function i defined as "Graphs" that takes in n and k for the number of graphs, and returns the plot of edges with vertices.
Then starting with n = 1 we have the following outputs using a loop we get that\newline
n = 1\newline
$$\includegraphics[]{more_systematic_graphs/figure_10.png}$$
n= 2\\
\includegraphics[scale = 0.4]{more_systematic_graphs/figure_20.png} \includegraphics[scale = 0.4]{more_systematic_graphs/figure_21.png}
\\
n=3\\
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_30.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_31.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_32.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_33.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_34.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_35.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_36.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_37.png}
\\
n=4\\
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_40.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_41.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_42.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_43.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_44.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_45.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_46.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_47.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_48.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_49.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_410.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_411.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_412.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_413.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_414.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_415.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_416.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_417.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_418.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_419.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_420.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_421.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_422.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_423.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_424.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_425.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_426.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_427.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_428.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_429.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_430.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_431.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_432.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_433.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_434.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_435.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_436.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_437.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_438.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_439.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_440.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_441.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_442.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_443.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_444.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_445.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_446.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_447.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_448.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_449.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_450.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_451.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_452.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_453.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_454.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_455.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_456.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_457.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_458.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_459.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_460.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_461.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_462.png}
\includegraphics[scale = 0.5]{more_systematic_graphs/figure_463.png}
\newpage

\section*{Classical Algorithm for finding ramsey numbers}
\subsubsection*{Thinking}
\underline{\centering{Goal:Write code that determines a Ramsey Number}}
\begin{itemize}
	\item i need to verify ramsey numbers
	\item use brute force method to verify if all graphs of n-vertices there will be either red or subgraphs. 
	\item use adjacency matrix code to determine if a rxr matrix of either empty graph or matrix with ones at off diagonal elements and zero at diagonal elements in the adjacency matrix
	\item firstly define the matrix of the complete graph call it blue\_clique, and an empty graph call it red\_clique
	\item create an empty vector this will keep track of which graphs has either a red clique or a blue clique
	\item if the graph in the graph set has either a red / blue clique the element of the graph in the graph set change the element to 1
	\item then use the empty vector to see if for a graph set of n vertices there is a zero in the vector then n is not a ramsey number
\end{itemize}

\begin{enumerate}
	\item Comparison set
	\item write the algorithm used (check online internet) pseudo-code algorithm in the write up
	\item need to implement Ramsey number search 
	\item explain how the recipe works type 
	\item write code as lean as possible to run in cluster
	\item table for different inputs(not complete in my machine )
\end{enumerate}
\%\% firstly starting with defining the graph plots\\
\% \underline{binary vector} - creating a vector of binary string of each graph in the graph set return the binary vector of the string ensuring that the vector has $\left(\frac{n^2-n}{2}\right)$ elements\\\\
\begin{itemize} \item BEGIN FUNCTION binary\_vector(number of vertices, graph number)
\begin{itemize}
	
\item INITIALIZE and Define parameters\\
set\\
n= number of vertices  \\
 m =$\left(\frac{n^2-n}{2}\right)$\\
binary\_vec = zeros(m)\\
binary(n)\\
L = len(binary(n))
\item BEGIN LOOP\\
FOR i FROM 1 to L\\
  \hspace*{0.5cm} DO binary\_vec(m-i-1) = REVERSE(binary)(i)\\
  END LOOP
\end{itemize}
\hspace*{0.5cm}RETURN binary\_vec\\
END FUNCTION\\\\
\%\% create a function that transposes the binary matrix into an empty matrix of n x n\\\\
\item BEGIN FUNCTION adjacency\_matrix(number of vertices,graph number)
\begin{itemize}
\item INITIALIZE and Define parameters\\
n= number of vertices\\
$m = \left(\frac{n^2-n}{2}\right)$\\
$A = zeros(n,n)$\\
b =  binary\_vector(n,graph number)\\
start\_index = 1
\item BEGIN LOOP\\
FOR i = 1 TO n\\
 \hspace*{0.5cm} DO\\
  \hspace*{0.5cm}index\_length = n-1-i\\
 \hspace*{0.5cm} end\_index = start\_index + index\_length\\
 \hspace*{0.5cm} A(i,i+1:) = b(start\_index , end\_index)\\
 \hspace*{0.5cm} start\_index = end\_index\\
END LOOP
 \item BEGIN LOOP\\
 FOR i = 1 TO n\\
 FOR j = 1 TO n\\
 \hspace*{0.5cm} DO A(j,i) = A(i,j)\\
 END LOOP

	RETURN A\\
\hspace*{-1cm}END FUNCTION\\
	\end{itemize}
\%\% create a function to plot graph, this takes in number of vertices and the graph number.\\
\%\% it returns a graph with red edges and blue edges
\item	BEGIN FUNCTION GRAPH(number of vertices , graph number)\\
\begin{itemize}

\item	INITIALIZE\\
	A = adjacency\_matrix\\
	b = binary\_matrix\\
	x = zeros(n)\\
	y = zeros(n)\\
	
	\item BEGIN LOOP\\
	FOR i = 1 TO n\\
	\hspace*{0.5cm} DO\\
	\hspace*{0.5cm} x = cos($\frac{2\pi}{n}i$)\\
	\hspace*{0.5cm}	y = sin($\frac{2\pi}{n}i$)\\
	END LOOP
	\item \hspace*{0.2cm} BEGIN LOOP\\
	\hspace*{0.5cm} FOR i = 1 TO n:\\
	\hspace*{0.5cm} FOR i = j TO n:\\
	\hspace*{0.5cm} DO\\
	\hspace*{1cm} IF A(i,j) = 1\\
\hspace*{1.5cm}	add\_line between points (x[i],x[j]) and (y[i],y[j]) with blue colour\\
\hspace*{1.5cm} add k at center for number of graph\\
\hspace*{1cm}	ELSE  A(i,j) = 0\\
\hspace*{1.5cm}	add\_line between points (x[i],x[j]) and (y[i],y[j]) with red colour\\
	\hspace*{1.5cm} put k for number of graph\\
RETURN PLOT\\
\end{itemize}
END FUNCTION\\\\
\%\% create a function that verifies if all the graphs of n vertices has either a red clique of order r or blue clique of order s\\
\%\% And if a clique does not exist then return the graph that does not contain the clique
\item BEGIN FUNCTION ramsey\_find(number of vertices , r , s)
\begin{itemize}
\item
INITIALIZE\\
n = number of vertices \\
$m = \left(\frac{n^2-n}{2}\right)$ \\
b = binary\_matrix(number of vertices,graph number)\\
A = adjacency\_matrix(number of vertices,graph number)\\
clique = graphs of size r and s 

\item BEGIN LOOP\\
\hspace*{1cm}FOR k = 1 TO $2^{m}$\\
\begin{itemize}
	\item \hspace*{1.5cm}BEGIN LOOP\\
\hspace*{1.5cm} FOR subgraph IN A\\
\hspace*{1.5cm} BEGIN LOOP\\
\hspace*{1.5cm} IF subgraph = size r or size s clique:\\
\hspace*{2cm}CONTINUE to the next graph\\
\hspace*{1.5cm}ELSE \\
\hspace*{2cm}BREAK LOOP\\
\hspace*{1.5cm} END LOOP\\

\end{itemize}
\hspace*{1cm} END k LOOP
\item BEGIN LOOP\\
\hspace*{1cm}IF clique not found\\
\hspace*{1.5cm} PRINT('(n) is a Ramsey Number R(r, s)')\\
\hspace*{1.5cm} PRINT(Graph(n,k))\\
\hspace*{1.5cm} BREAK LOOP\\
\hspace*{1cm}ELSE \\
\hspace*{1.5cm} return '(n) is a Ramsey Number R(r, s)'\\
 END LOOP\\
\end{itemize}
END FUNCTION
\end{itemize}
\newpage
\%\%\% Goal\\
\%\%\% Create a function that searches for ramsey numbers \\
\begin{itemize}
\item FUNCTION Ramsey\_Number(r : INTEGER , s : INTEGER)\\
\begin{itemize}
\item  n $\leftarrow$ 2 (*starting at 2 vertices*)
\item N $\leftarrow$ total\_graphs(n)
	\item A $\leftarrow$ adjacency\_matrix(n,graph)
\item G $\leftarrow$ draw\_graph(n,graph)
\item comb1 $\leftarrow$choose different vertex combination
\item comb2 $\leftarrow$choose different vertex combination
\item WHILE TRUE DO:
\begin{itemize}
\item FOR graph $\leftarrow$ 1 TO N:


\begin{itemize}
\item FOR vertex in comb1:
\item A[vertex,vertex+1]
\section*{Pseudocode}
\end{itemize}
\end{itemize}
\end{itemize}
\end{itemize}
\newpage
\RestyleAlgo{ruled}
\SetKwFunction{Fnumber}{total\_edges} % Defines a function named 'AddNumbers' that can be called with \
\SetKwFunction{Fdraw}{fill\_bits} % Defines another function
\SetKwFunction{Flabel}{label\_graph} % Defines another function
\SetKwFunction{Fdraw}{draw\_graph} % Defines another function
\SetKwFunction{Fempty}{empty\_graph} % Defines a function named 'AddNumbers' that can be called with \
\SetKwFunction{Fcomplete}{complete\_graph} % Defines another function
\SetKwFunction{Freverse}{Reverse} % Defines another function
\SetKwFunction{Fbinary}{binary\_string} % Defines another function
\SetKwFunction{Ftotal}{total\_graphs} % Defines another function
\SetKwComment{Comment}{/* }{ */}
\begin{itemize}
\item This function verifies the graphs of n vertices has either a red clique of order r or blue clique of order s\\
And if a clique does not exist then return the graph that does not contain the clique\\
\begin{algorithm}[H]
	\caption{Main Function}\label{alg:two}
	\DontPrintSemicolon
	\KwIn{integers r and s}
	\KwOut{minimum n that has r or s size clique}
	
	\Begin{
		Set\;
		$n \gets 1$  \Comment{starting with 1 vertex}\;
		
		\Repeat{all graphs contain clique} {
			$m \leftarrow$ \Fnumber{$n$}\;
			$N \gets \Ftotal{n}$\;
			$red\_clique \gets$\Fempty{$r$}\;
			$blue\_clique \gets $ \Fcomplete{$s$}\;
			plot $\gets$ \Fdraw{$n,k$} \;
			$A \gets$ \Flabel{$n,k$}\;
			
			\For{$k$ from 1 to $2^m$} {
				\If{A has red clique or blue clique}{
					Continue
				}
				\Else{
					return plot\;Break
				}
			}
			
			\If{one graph has no clique}{
				$n \gets n+1$
			}
		}
	}
\end{algorithm}
\item create a function that labels graphs
\begin{algorithm}[H]
	
	\DontPrintSemicolon
	\KwIn{integers $n$,k}\Comment*[r]{n is the number of vertices and k represents the graph number}\;
	\KwOut{graph\_label}
	\Comment{This function labels all the graphs in the graph set}
	\Begin{
		$m \leftarrow$ \Fnumber{$n$}\; % Calling the previously defined function
		$b \leftarrow$  binary\_string(n,k)\\
		adj $\leftarrow$ zeros(n,n)\;
		N = \Ftotal{$n$}\;
		\For{ i to $N$}{fill\_bits(adj,b)}
		\KwRet adj\;
	}
\caption{graph\_label(n,k) Function}
\end{algorithm}

\item create a function to plot graph
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{integers $n$,k}\Comment*[r]{n is the number of vertices and k represents the graph number}\;
	\KwOut{graph\_plot}
	\Comment{This function returns a plot of the graph using the graph labels }
	\Begin{
		$m \leftarrow$ \Fnumber{$n$}\; % Calling the previously defined function
		A $\leftarrow$ \Flabel{n,k}\\
		\For{ i=1 to n}{\For{j =1 to n}{\If{A[i,j]=1 }{add edge}\Else{add red edge}}}
		\KwRet plot\;
	}
	\caption{draw\_label(n,k) Function}
\end{algorithm}


\item This function fills a matrix with the binary vector

\begin{algorithm}[H]
	\DontPrintSemicolon
\KwIn{matrix $A$, vector $b$}
\KwOut{A filled with elements of b}
\Comment{This function fills upper element of the A matrix using elements of b}\;
\Comment{Assumption the number of elements in the upper matrix of A is equal to number of elements in b}
	\Begin{
		start $\gets$ 1 \Comment{starting point of the b vector}\;
		
		$n \leftarrow $ length(A)\;

		
		\For{i 1 to n}{length\_cut $\gets$ n-i \Comment{this is the number of elements in the row}\;
				end $\gets$ start + length\_cut \Comment{the cut off at which the b vector must stop}
				A[i,i+1] = b[start, end] \;
			start $\gets$ end \Comment{update the starting point after each iteration}}\;
			\For{i 1 to n}{\For{i 1 to n}{A[j,i]=A[i,j]}\Comment{This ensures that the matrix is symmetric}}
		\KwRet $A$\;
	}
	\caption{fill\_bits(A, b) Function}
\end{algorithm}
\item Create a function that returns the binary vector of a graph in the graph set.\\
This ensures that the binary string can have total number of edges so that each possible edge can be accounted for in the adjacency matrix.
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{integers $n$, $k$}
	\KwOut{binary string of k}
	\Begin{
		
		$m \gets $ \Fnumber\;
		$b$ $\gets$ zeros(m) \Comment*[r]{ensures that the binary string can have total number of edges}\;
		graph\_number $\gets$ binary(k)\;
		\For{edge 1 to m }{b[m+1-edge] = Reverse(graph\_number)[edge]\Comment*[r]{fills the binary vector using the binary string} } \
		\KwRet $b$\;
	}
	\caption{binary\_string(n,k) Function}
\end{algorithm}
\item This function calculates the possible edges in an n vertex graph
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{An integer $n$}
	\KwOut{Returns total number of edges}
	\Begin{
		
		$m \leftarrow \frac{n^2-n}{2}$\; \Comment{given n we have ${\frac{n^2-n}{2}}$ possible number of graphs}
		\KwRet $m$\;
	}
	\caption{total\_edges(n) Function}
\end{algorithm}
\item This function calculates the total graph in an n vertex
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{An integer $n$}
	\KwOut{Returns total number of graphs}
	\Begin{
		
		
		$N \leftarrow \Fnumber{n}$\; \Comment{given n we have $^{\frac{n^2-n}{2}}$ possible number of graphs}
		\KwRet $2^N$\;
	}
\end{algorithm}
\item This function is for reversing vectors
\begin{algorithm}[H]
		\Comment{The function reverses the vector by swapping elements}
	\DontPrintSemicolon
	\KwIn{vector v}
	\KwOut{reverse of the vector}
\Begin{

	$n \leftarrow \text{length}(v)$\;
	\For{$i$ from 1 to $\lfloor n/2 \rfloor$}{
		\Comment{Swap the element at position i with the element at position n-i+1}
		temp $\leftarrow v[i]$\;
		$v[i] \leftarrow v$[n-i+1]\;
		$v$[n-i+1]$ \leftarrow temp$\;
	}
	\KwRet $v$\;
}

	\caption{Reverse(v) Function}
\end{algorithm}
\item This function is to create an empty graph label
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{An integer $r$}
	\KwOut{empty graph with no edges}
	\Begin{
		
		$clique \leftarrow $ zeros(r,r)\;
		\KwRet $clique$\;
	}
	\caption{empty\_graph(r) Function}
\end{algorithm}
\item This function returns the complete graph
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{An integer $r$}
	\KwOut{complete graph with edges}
	\Begin{
		
		$clique \leftarrow $ ones(r,r)-identity(r,r)\;
		\KwRet $clique$\;
	}
	\caption{complete\_graph(r) Function}
\end{algorithm}
\end{itemize}
\newpage
\subsubsection*{Time Taken for to verify known ramsey numbers}
\begin{table}[hbt!]
	\centering
	\begin{adjustbox}{max width=\textwidth}
		\begin{tabular}{| r | c |}
	\toprule
	\multicolumn{1}{|c|}{Ramsey Number} & Time Taken(s) \\
	\midrule
	\textbf{R(2,2) = 2} & $2.942 \times 10^{-4}$ \\
	\hline
	\textbf{R(2,3) = 3} & $9.022 \times 10^{-4}$ \\
	\hline
	\textbf{R(2,4) = 4} & $8.728 \times 10^{-3}$ \\
	\hline
	\textbf{R(2,5) = 5} & $1.223 \times 10^{-1}$ \\
	\hline
	\textbf{R(2,6) = 6} & 2.756 \\
	\hline
	\textbf{R(2,7) = 7} & $1.722 \times 10^{2}$ \\
	\hline
	\textbf{R(2,8) = 8} & $4.396 \times 10^{4}$ \\
	\hline
	\textbf{R(2,9) = 9} & \\
	\hline
	\textbf{R(2,10) = 10} & \\
	\hline
	\textbf{R(3,3) = 6} & 8.671 \\
	\hline
	\textbf{R(3,4) = 9} & \\
	\hline
	\textbf{R(3,5) = 14} & \\
	\hline
	\textbf{R(3,6) = 18} & \\
	\hline
	\textbf{R(4,4) = 18} & \\
	\bottomrule
\end{tabular}
	\end{adjustbox}
	\caption{Ramsey Number Calculation Times}
	\label{tab:ramsey_times}
\end{table}

\subsubsection*{What i notice}


\begin{enumerate}
\item The runtime for finding each ramsey number increases exponentially
\item The runtime is lower when instead of finding $R(s,r)$ when $s<r$.
\end{enumerate} 
\newpage
\section*{Quantum Computing}
Quantum computers store information in quantum bits (qubits).
A spin-half system is a system that has 2 states spin up and spin down similar to qubits.
Mathematically qubits are represented  as in Dirac notation 
\begin{center}
	0 bit $=|0\rangle $ \\1 bit $=  |1\rangle$
\end{center}
If n particles are added we have $2^n$ states or $2^n$ pieces of information. 
For n = 2 we have 4 different states which are,
\begin{equation}
	|\psi\rangle =c_1 |00\rangle+c_2 |01\rangle+c_3 |10\rangle+ c_4 |11\rangle
\end{equation}
Where in this new state \begin{equation}|00\rangle = |0\rangle\otimes|0\rangle  =	\begin{pmatrix}
		1\\0\\0\\0
\end{pmatrix}\end{equation}
The other vectors are given by,
$$|01\rangle =	\begin{pmatrix}
	0\\1\\0\\0
\end{pmatrix}|10\rangle =	\begin{pmatrix}
	0\\0\\1\\0
\end{pmatrix}|11\rangle =	\begin{pmatrix}
	0\\0\\0\\1
\end{pmatrix} $$
This represents a 2-qubit superposition state with the coefficients $c_i$ are complex and like the 1-qubit system they tell us the probability of measuring their respective states.\\
These matrices are known as operators which are linear, meaning they act on these states \cite{AndrewSteane,mcintyre_quantum_2012}.
\begin{equation}
	\sigma_x =\begin{pmatrix}
		0&1\\1&0
	\end{pmatrix},
	\sigma_y =\begin{pmatrix}
		0&-i\\i&0
	\end{pmatrix},\sigma_z =\begin{pmatrix}
		1&0\\0&-1
	\end{pmatrix}
\end{equation}
\begin{enumerate}
\item The pauli matrices for a state with more than 1 qubit is defined by 
\begin{equation}\sigma_x^{\otimes n} =\sigma_x \otimes \sigma_x \otimes \sigma_x \otimes ...\sigma_x \end{equation}n times\\
Example of 2 state system 
$$\sigma_x^{\otimes2} =\sigma_x \otimes \sigma_x $$
$$\sigma_x^{\otimes2} =\begin{pmatrix}
	0&1\\1&0
\end{pmatrix} \otimes \begin{pmatrix}
	0&1\\1&0
\end{pmatrix}$$
This matrix tensor product is represented by 
$$\begin{pmatrix}
0 \begin{pmatrix}
	0&1\\1&0
\end{pmatrix} &1 \begin{pmatrix}
0&1\\1&0
\end{pmatrix}\\
1 \begin{pmatrix}
	0&1\\1&0
\end{pmatrix}&0\begin{pmatrix}
0&1\\1&0
\end{pmatrix}
\end{pmatrix}$$
$$\sigma_x^{\otimes2}=\begin{pmatrix}

		0&0&0&1\\

		0&0&1&0\\

		0&1&0&0\\

		1&0&0&0

\end{pmatrix}$$
\end{enumerate}

There are 6 different types of Quantum computers namely
\begin{enumerate}
\item Superconducting Ions-
use superconducting circuits as qubits, which are made from materials that can conduct electricity without resistance at extremely low temperatures.
Superconducting qubits work by exploiting the quantum properties of superconducting circuits. 
These circuits have two states, representing 0 and 1, and can exist in superposition and be entangled.
\item Neutral Atom Quantum Computers -
Neutral atom quantum computers use neutral atoms as qubits. 
The atoms are trapped in place using optical tweezers (focused laser beams) and manipulated by lasers. 
Atoms are individually trapped and held in place using precise laser beams. 
The internal quantum states of these atoms (such as their electron configurations) are used to represent quantum bits (qubits).
 Quantum operations are performed using lasers to manipulate these states.
\item Photonic -
Photons(particles of light) are used as qubits.
These photons can carry quantum information and be manipulated using optical components. 
Photons are generated, manipulated, and measured using optical components like beamsplitters, mirrors, and waveguides.
 Quantum operations are performed using properties of photons such as polarization, phase, and path.
\item Trapped Ion Quantum Computers-
Trapped ion quantum computers use individual ions (charged atoms) as qubits, which are manipulated using electromagnetic fields. Ions are trapped in a vacuum chamber using electromagnetic fields and manipulated with lasers. 
The internal energy states of the ions are used to represent quantum bits.
\item Topological Quantum Computers -
Topological quantum computers aim to use exotic particles called anyons to represent qubits. 
These qubits are more robust against errors due to their topological nature, which means that information is stored in the global properties of the system rather than the individual states of particles.
\item Quantum Dots Quantum Computers - 
Quantum dots are semiconductor-based structures that confine electrons in all three spatial dimensions, effectively creating artificial atoms. 
These quantum dots can be used as qubits. 
A quantum dot is essentially a tiny region of a semiconductor material where an electron can be confined.
 The qubit is represented by the spin or energy level of the electron confined in the quantum dot.
 External electric or magnetic fields are used to control the qubits.
\end{enumerate}
\textbf{IBM}:\\
IBM is a leader in superconducting quantum computing, with its IBM Quantum platform that provides cloud-based quantum computing services. 
Their quantum processors, such as the Eagle and Condor chips, use superconducting qubits to scale up quantum systems.

\subsection*{Adiabatic Quantum Algorithm}
Adiabatic Quantum Computing (AQC) seeks to evolve a state under a time-dependent Hamiltonian 
$H(t)$. More specifically, a system of qubits is initialized into an easy-to-prepare ground state of a Hamiltonian $H_0$.
Then, the system is allowed to interact through the Hamiltonian .
The quantum algorithm's goal is not to find a graph with a specific number of cliques. Its goal is to find the graph that has the absolute minimum number of cliques—which corresponds to the state with the lowest possible energy.
\begin{equation}
H(t)=(1-t)H_0+tH_1, t\epsilon [0,1]
\label{evolution}
\end{equation}
The equation ~\ref{evolution} is defined as the evolution. 
Time is varied slowly so that the system of qubits always remains in the ground state throughout the evolution \cite{Kolotouros2022}.
\begin{itemize}
	\item  Adiabatic quantum computing(AQC) started as an approach to solving optimization problems
	\item in AQC the computation proceeds from an initial Hamiltonian whose ground
	state is easy to prepare, to a final Hamiltonian whose
	ground state encodes the solution to the computational problem.
\end{itemize}
\begin{itemize}
	\item A type of quantum computing that uses Adiabatic theorem to perform calculations
	\item Adiabatic Theorem says that a quantum mechanical system, starting in an eigenstate of its initial Hamiltonian, will remain in the corresponding instantaneous eigenstate of the Hamiltonian as it is changed slowly over time, provided there is a sufficiently large "gap" (or separation) between its energy level and other energy levels.
	\item adiabatic quantum computing relies on the use of continuous transformations
\end{itemize}
In the paper \cite{Kolotouros2022} they simulate adiabatic quantum computing with parameterized quantum circuits using qiskit or Qiskit Statevector. 
This means Adiabatic quantum computing can be applied in qiskit.
\\
\\
\subsection*{Differences between Analog and Digital Computing}
\begin{table}[h!]
	\centering
	
	\begin{tabularx}{\textwidth}{|X|X|}
		\hline
	 \textbf{Analog Quantum Computing} & \textbf{Digital Quantum Computing} \\\hline
	 There is a problem Hamiltonian&Uses quantum circuits \\
		\hline
	The quantum state is changing continuously&	\\\hline
		 uses continuous variables to represent and manipulate quantum information &operates on continuous quantum states  \\
		\hline
		  Relies on discrete qubits and gates & Employs continuous transformations \\
		\hline
It’s easier to implement architecturally & Can introduce errors with every gate operation, which limits practicality \\
		\hline
		 Offers the potential for more natural and efficient simulations of certain quantum systems. & Applications in quantum simulation, optimization \\\hline
	\end{tabularx}
	\caption{Differences between Analog and Digital Quantum Computing \cite{Quera_Analog_Quantum_Computing}}
	\label{tab:quantum_comparison}
\end{table}
\newpage
\subsection*{Grover's Algorithm}

\begin{itemize}
\item Search Algorithm 
\item Can search through unordered list
\item uses superposition and interference to search
\item offers a quadratic speed up 
\begin{itemize}
\item If a list has $N$ elements the algorithm would have $\mathcal{O}(\sqrt{N})$ iterations
\item for a list with 16 elements there would be 4 qubits required
\end{itemize}
\subsubsection*{Procedure}
\begin{itemize}
	\item Apply the oracle
	\item Apply the Hadamard Gate to turn all states into superposition
\end{itemize}
\end{itemize}
\subsubsection*{Pseudocode For Grover's Algorithm}
\subsubsection*{Difference between Grover and VQE}
\begin{table}[hbt!]
	\centering
	\caption{Comparison of Grover's Algorithm and VQE}
	\label{tab:grover_vqe_comparison}
	\begin{adjustbox}{max width=\textwidth}
		\begin{tabular}{|c|c|c|}
			\toprule
		
			& \textbf{Grover's Algorithm} & \textbf{VQE} \\
			\midrule
			\textbf{Primary Goal} & Unstructured search & Find ground state energy \\
			\hline
			\textbf{Optimization Type} & Search-based & Energy minimization \\
			\hline
			\textbf{Uses Hamiltonian} &uses an oracle & Yes \\
			\hline
			\textbf{Theoretical Speedup} & Quadratic ($O(\sqrt{N})$) & Not specified\\
	
			\hline
			\textbf{Initialization} & Initialize states to superposition & Also initializes states at the beginning of algorithm  \\
			\bottomrule
		\end{tabular}
	\end{adjustbox}
\end{table}
\newpage

\subsection*{Quantum Algorithm from \cite{PhysRevA.93.032301}}
\begin{itemize}
	\item  The task is transformed to check whether the ground state energy of
	the problem Hamiltonian equals or greater than zero.
	\item The problem is turned into a decision one.
	\item From the fact that there are $L = \frac{n^2-n}{2}$ possible edges, and this can be represented as a binary vector of length $L$ call it $a$
	\item There are a total number of $2^L$ graphs in total, there would be a total number of $N = 2^L$ vectors.
	\item For given n, s and r and a given number in the set $N$, count the total number of s sized clique and r sized cliques.
 	\item Define the energy function as the total number of s sized cliques and total number of r sized cliques for a certain graph.$$h^n_{s,r}(a) = C^n_s(a)+I^n_r(a)$$
	$C^n_s(a)$ is the total clique of size s found in the graph $a$ and $I^n_s(a)$ is the total clique of size r found in the graph $a$
	\item find the way in which the subgraphs are chosen in the binary string
	\item If either of them is not found then the energy would be 0, else if a clique is found then 1 would be added to the energy function then the energy function would be a positive number.
	\item If the energy is zero for all graph of $n$ vertices then the $n$ is not Ramsey number $s,r$ and if the energy is positive then 
	\item The problem Hamiltonian is defined as $$H_p|z_1 z_2 z_3.....z_N\rangle =h^n_{s,r}(a)|z_1 z_2 z_3.....z_N\rangle$$
	\item $H_p|z_1 z_2 z_3.....z_N\rangle =0$ when a bit string does not contain a clique of either size s or r.
	\item The algorithm starts with lower bound and if the $n$ is not a Ramsey number or if  $H_p =0$ $n$ is increased until one where $H_p$ is not 0 is found.
	\item  Quantum Register Q: This is the total collection of qubits used for the algorithm. It's the quantum equivalent of a computer's memory register.
	Quantum Register Q: This is the primary memory for the algorithm
	\item The algorithm uses ancilla qubit these are extra bits (units of information) used in computing paradigms that require reversible operations.
	\item A quantum register containing an ancilla qubit and L qubit quantum register
	\item It also uses a probe qubit, A probe qubit is a quantum bit used to indirectly characterize or measure a quantum system of interest, such as its temperature, topological edge states, or quantum phase transitions, by interacting with it and observing the resulting dynamics or changes in the probe's state. The probe qubit acts as a sensor, converting information about the target system into a measurable signal, which can then be used to deduce properties of the system that are otherwise difficult to access. 
	\item There are a total of $L+2$ total qubits, including $L$ graph qubits, ancilla qubit and a probe qubit.
	\item $$H = -\frac{1}{2}\omega\sigma_z+I_2\otimes H_Q+c \sigma_x\otimes A$$
	\item The system is allowed to evolve with time.
	\item the paper uses a matrix to encode the entire problem space. The quantum computer's job is not to check every configuration, but to find the lowest possible energy of that complex matrix. If that lowest energy is zero, it means
	 a valid clique exists. If the lowest energy is greater than zero, it means no such clique exists.
\end{itemize}
\subsubsection*{The Algorithm}
\begin{itemize}
	\SetKwFunction{Fenergy}{energy} % Defines another function
	\SetKwFunction{Ftotal}{total\_graphs} % Defines another function
\item
\begin{algorithm}[H]
	\caption{Main Function}
	\DontPrintSemicolon
	\KwIn{integers r and s,lower\_bound,}
	\KwOut{minimum n that has r or s size clique}
	\Begin{$n0\gets$ lower\_bound\;
		$L\gets \Fnumber{n}$\;
		$N \gets \Ftotal{n}$\;
		$H_P = \Fenergy{n,k}$\;
		\textbf{Initialize} main quantum register $Q$ ($L+1$ qubits) to the reference state $|\Phi\rangle = |0\rangle^{\otimes(L+1)}$\;
		\textbf{Initialize} the probe qubit to its excited state $|1\rangle$\;
		 \If{the probability measurement indicates the ground state energy is NOT zero}{
			\tcc{If the ground state energy is non-zero, it means every graph for this $n$ must contain a clique or independent set.}
			\KwRet n
		}
		\Else{
			\tcc{A graph with a zero-energy was found}
			 $n\gets n+1$
		}
	}
\end{algorithm}
\item
\begin{algorithm}[H]
	\caption{Hamiltonian Function}
	\DontPrintSemicolon
	\KwIn{integers r and s,lower\_bound,}
	\KwOut{minimum n that has r or s size clique}
	\Begin{$L\gets \Fnumber{n}$\;
		$N \gets \Ftotal{n}$\;
		$n0\gets$ lower\_bound}
\end{algorithm}
\item Construct the Problem Hamiltonian $H_P$ for the $n$-vertex graph
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{integer $n$,matrices $sigma_x$}
	\KwOut{integer $\geq 0$}
	\Begin{
		
		$m \gets $ \Fnumber{$n$}\;
		$N \gets $\Ftotal{$n$}\;
		$a \gets $\Fbinary{$n,k$}\;
		$clique \gets$\Fcomplete{$r$}\;

		$independent\_set$ $\gets$ \Fempty{$s$}\;
				$h\gets 0$\;
		\For{graph $= 1$ to $N$ }{\If{$a(n,graph) $ has $clique$}{$h \gets h+1$\; continue until all cliques are counted}\Else{if $a(n,graph) $ has $independent\_set$\;{$h \gets h+1$\;} continue until all independent\_sets are counted}} 
		\KwRet $h$\;
	}
	\caption{energy(n,k) Function}
\end{algorithm}
\item
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{integers $n$, $k$}
	\KwOut{binary string of k}
	\Begin{
		
		$m \gets $ \Fnumber{n}\;
		$b$ $\gets$ zeros(m) \Comment*[r]{ensures that the binary string can have total number of edges}\;
		graph\_number $\gets$ binary(k)\;
		\For{edge 1 to m }{b[m+1-edge] = Reverse(graph\_number)[edge]\Comment*[r]{fills the binary vector using the binary string} } \
		\KwRet $b$\;
	}
	\caption{binary\_string(n,k) Function}
\end{algorithm}

\item This function calculates the total graph in an n vertex
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{An integer $n$}
	\KwOut{Returns total number of graphs}
	\Begin{
		
		
		$N \leftarrow \Fnumber{n}$\; \Comment{given n we have $^{\frac{n^2-n}{2}}$ possible number of graphs}
		\KwRet $2^N$\;
	}
		\caption{total\_graphs(n) Function}
\end{algorithm}
\item
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{An integer $n$}
	\KwOut{Returns total number of edges}
	\Begin{
		
		$m \leftarrow \frac{n^2-n}{2}$\; \Comment{given n we have ${\frac{n^2-n}{2}}$ possible number of graphs}
		\KwRet $m$\;
	}
	\caption{total\_edges(n) Function}
\end{algorithm}
\item This function is to create an independent set of r vertices
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{An integer $r$}
	\KwOut{empty graph with no edges}
	\Begin{
		
		$clique \leftarrow $ zeros(r,r)\;
		\KwRet $clique$\;
	}
	\caption{empty\_graph(r) Function}
\end{algorithm}
\item This function returns the clique of r vertices
\begin{algorithm}[H]
	\DontPrintSemicolon
	\KwIn{An integer $r$}
	\KwOut{complete graph with edges}
	\Begin{
		
		$clique \leftarrow $ ones(r,r)-identity(r,r)\;
		\KwRet $clique$\;
	}
	\caption{complete\_graph(r) Function}
\end{algorithm}
\end{itemize}
\newpage
\bibliography{sample.bib}
\end{document}
\begin{itemize}
	
	\item VQE
	\item Grover adaptive search(QUBO highest term quadratic)
	\item Use order reduction
\end{itemize}